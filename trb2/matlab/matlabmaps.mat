exampleMap1 = struct();
exampleMap1.map = [
  '######';
  '#@ $.#';
  '######'
];

exampleMap2 = struct();
exampleMap2.map = [
    '######';
    '# $ .#';
    '#@   #';
    '######'
];

exampleMap3 = struct();
exampleMap3.map = [
    '#########';
    '#.$@$  .#';
    '#########'
];

clc;

function newData = getInitialSolutionSokoban(data)

    newData = data;
    map = data.map;
    
    movements = {[0, -1], [0,  1], [-1, 0], [1, 0]};

    % FIND PLAYER
    [row, col] = find(map == '@');
    if isempty(row)
        [row, col] = find(map == '+');
    end

    % GENERATE MOVEMENT
    mov = movements{randi(4)};
    newRow = row + mov(1);
    newCol = col + mov(2);

    if newRow < 1 || newRow > size(map,1) || newCol < 1 || newCol > size(map,2)
        return
    end

    newPos = map(newRow, newCol);

    % INVALID MOVE CASE
    if newPos == '#'
        return
    end

    % PUSH CASE
    if newPos == '$' || newPos == '*'
        checkRow = newRow + mov(1);
        checkCol = newCol + mov(2);

        if checkRow < 1 || checkRow > size(map,1) || checkCol < 1 || checkCol > size(map,2)
            return
        end

        % nova posição
        checkPos = map(checkRow, checkCol);

        % INVALID PUSH CASE
        if checkPos == '#' || checkPos == '$' || checkPos == '*'
            return
        end

        % MOVE BOX
        if checkPos == '.'
            map(checkRow, checkCol) = '*';
        else
            map(checkRow, checkCol) = '$';
        end

        % MOVE PLAYER
        if newPos == '*'
            map(newRow, newCol) = '+';
        else
            map(newRow, newCol) = '@';
        end

        if map(row, col) == '+'
            map(row, col) = '.';
        else
            map(row, col) = ' ';
        end

        newData.map = map;
        return
    end

    % BASE MOVE CASE
    if newPos == '.' 
        map(newRow, newCol) = '+';
    else
        map(newRow, newCol) = '@';
    end

    if map(row, col) == '+'
        map(row, col) = '.';
    else
        map(row, col) = ' ';
    end

    newData.map = map;
end

function score = evalFunc(state)
    map = state.map;

    [goalRows, goalCols] = find(map == '.' | map == '+');
    [boxRows, boxCols] = find(map == '$');

    boxesOnGoals = sum(map(:) == '*');

    totalBoxDistance = 0;
    for i = 1:length(boxRows)
        boxPos = [boxRows(i), boxCols(i)];

        minDist = inf;
        for j = 1:length(goalRows)
            goalPos = [goalRows(j), goalCols(j)];
            dist = abs(boxPos(1) - goalPos(1)) + abs(boxPos(2) - goalPos(2));
            if dist < minDist
                minDist = dist;
            end
        end

        totalBoxDistance = totalBoxDistance + minDist;
    end

    score = -totalBoxDistance + 10 * boxesOnGoals;
end

function neighbor = getRandomNeigh(state)
    % Tenta gerar um vizinho válido a partir do estado atual
    maxTries = 50;  % evitar ciclos infinitos
    for i = 1:maxTries
        neighbor = getInitialSolutionSokoban(state);  % aplica movimento aleatório

        if ~isequal(neighbor.map, state.map)
            return  % retorno se foi gerado um estado diferente (válido)
        end
    end

    % Se não conseguir gerar vizinho válido, retorna o mesmo (pode melhorar isso)
    neighbor = state;
end

function x = p(fu, fv, T, sense)
    % Evita divisão por zero
    if fu == 0
        fu = 1e-10;
    end

    if strcmp(sense, 'max')
        delta = fv - fu;
    elseif strcmp(sense, 'min')
        delta = fu - fv;
    else
        error('Sense deve ser "maximize" ou "minimize"');
    end

    if delta >= 0
        x = 1; % nova solução melhor ou igual => aceita sempre
    else
        x = exp(delta / (abs(fu) * T)); % aceita pior solução com probabilidade decrescente
    end
end

function r = myRand()
    r = rand();
end

function bool = isOptimum(state)
    map = state.map;
    
    boxesOutsideGoals = sum(map(:) == '$');
    
    if boxesOutsideGoals ~= 0
        bool = false;
    else
        bool = true;
    end
end

function newtemp = Temp(t, Tmax, R)
%Outra hipotese: decrescimento quadratico
% R = ]0,1[, e.g., R = 0.99 (mais lento) ou 0.1 (mais rapido)
% newTemp = R*Tmax;
    newtemp = Tmax * exp(-R * t);
end

function Res = SA(Tmax, Tmin, R, k, ...
    data, getInitialSolution, getRandomNeigh, evalFunc, ...
    isOptimum, sense)

    % Rate increment variable
    t = 0;
    % Step 1  Make T = Tmax and
    T = Tmax;
    % Number of evaluations
    numEvaluations = 0;
    % Variable used to specify stop criteria
    foundOptimum = false;

    % Choose a solution u (at random) and compute fu = f(u) 
    maxTries = 100;
    for attempt = 1:maxTries
        u = getInitialSolution(data);
        if ~isequal(u.map, data.map)
            break;
        end
    end
    fu = evalFunc(u);
    fprintf('Initial cost: %d\n', fu);
    % Increment number of evaluations
    numEvaluations = numEvaluations + 1;
      
    z = 1;
    F(z) = fu;
    z = z+1; 
    
    while (~foundOptimum)
        % Step 2  Select a neighbor of u, say v 
        %         If f(v) < f(u) make u = v; 
        %         Else make u = v with probability  
        %              p = exp((fu-fv)/(fu * T))) 
        % 
        %         Repeat Step 2   k times 
        i = 0;
        while (i < k && ~foundOptimum)
            % Select a neighbor of u, say v. 
            v = getRandomNeigh(u);
            % Evaluate v
            fv = evalFunc(v);
            % Increment number of evaluations
            numEvaluations = numEvaluations + 1;
            
            % If f(v) < f(u) (minimization) make u = v; 
            % Else make u = v with probability  
            %   p = exp((fu-fv)/(fu T))) 
            dif = fv-fu;
            if (strcmp(sense, 'maximize'))
                dif = -dif;
            end
                
%             if (fv < fu) % Minimization problem
%             if (fv > fu) % Maximization problem

            fprintf('fu (sol) = %d, fv (new neighbour) = %d\n', fu, fv); 

            if (dif < 0)
                disp('Neighbour accepted')
                u = v;
                fu = fv;
            else
                prob = p(fu, fv, T, sense)
                x = myRand()
                if (x <= prob)
                    % Accept this solution
                    u = v;
                    fu = fv;
               end
            end
            % Make i = i+1. 
            i = i + 1;
            
            F(z) = fu;
            z = z+1;
            
            % if optimum found then stop.
            if isOptimum(u)
                foundOptimum = true;
            end
        end

        if ~foundOptimum
            % Step 3  Make t = t+1; Set T = T(t) 
            % see Eq.(4) of lecture notes
            t = t + 1;
            T = Temp(t, Tmax, R);
            % If  T < Tmin  Stop.  
            if (T < Tmin)
                break;
            end
        end
    end
    
    disp('BestCost: '); 
    disp(fu);
    
    disp('numEvaluations: '); 
    disp(numEvaluations);
    
    Res = struct('T', T, 'NumEvaluations', numEvaluations, 'Cost', fu, ...
        'Tmax', Tmax, 'Tmin', Tmin, 'R', R, 'k', k, ...
        'u', u.map, 'F', F, 's', u);
    
    figure(1);
    plot(F);
    %pause
end

Tmax = 100;
Tmin = 1e-3;
R = 0.95;
k = 100;

Res = SA(Tmax, Tmin, R, k, ...
    exampleMap2, ...
    @getInitialSolutionSokoban, ...
    @getRandomNeigh, ...
    @evalFunc, ...
    @isOptimum, ...
    'max');

%disp('Mapa inicial:');
%disp(exampleMap3.map);
%
%move = getInitialSolutionSokoban(exampleMap3);
%
%disp('Output:');
%disp(move.map);
%
%eval = evalFunc(move);
%
%disp('Score:');
%disp(eval);
